---
title: "autoemulate"
subtitle: "A Python package for making emulation easy"
format:
  revealjs:
    logo: pics/logo_white.png
    incremental: true  
    theme: night
    footer: "autoemulate"
jupyter: python3
---

## Why do we emulate?

Simulations can be **slow** and **expensive**, making it hard to do:

:::: {.columns}

::: {.column width="50%"}
* (Fast) prediction
* Sensitivity analysis
* Optimization
* Uncertainty Quantification
:::

::: {.column width="50%"}
![Complex simulation](pics/simulation.png)
:::


::::

## Building an emulator is not easy

1) Experimental design
    * At which points should we run the simulation?
        * -> each run is expensive

2) Modelling
    * Model selection 
    * Chosing hyperparameters



## Projectile motion with drag

![Example simulation of projectile motion with drag for ùê∂=0.01
 kg/m and ùë£0=100 m/s computed via numerical integration.](pics/projectile_motion.png)



## Projectile motion with drag
```{python}
#| echo: True
import numpy as np
from autoemulate.experimental_design import LatinHypercube
from autoemulate.demos.projectile import simulator

lhd = LatinHypercube([(-5., 1.), (0., 1000.)])
X = lhd.sample(150)
y = np.array([simulator(x) for x in X])

print(f"Input variables:\n{X[:5]}\n")
print(f"Output variables:\n{y[:5]}")
```


## autoemulate

```{python}
#| echo: True
#| output: asis
from autoemulate.compare import AutoEmulate

ae = AutoEmulate()
ae.setup(X, y)
best = ae.compare()
```

## autoemulate - results

```{python}
#| echo: True
ae.print_results()
```

## autoemulate - plots

```{python}
#| echo: True
#| layout-nrow: 2
ae.plot_results()
```

```{python}
#| echo: True
#| layout-nrow: 2
ae.plot_results('GaussianProcessSk')
```

## Customising

`autoemulate` runs out of the box, but can be configured!
```{python}
#| echo: true
#| eval: false

# set up
ae = AutoEmulate()
ae.setup(X, y,                      # simulation input and output
         use_grid_search=True,      # search for best hyperparameters
         grid_search_type='random', # hyperparameter search strategy
         normalise=True,            # standardise input 
         fold_strategy='kfold',     # use k-fold cross-validation
         n_jobs=4)                  # parallelise computation
```

## Summary


